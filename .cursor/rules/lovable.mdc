---
description: 
globs: 
alwaysApply: true
---
# Cursor Rules for Loveable.dev Project

## General Guidelines

- Prioritize clarity and readability; use clear code over clever one-liners.
- Use descriptive names for variables, functions, components, and files; avoid non-standard abbreviations.
- Maintain folder structure: components in src/components, pages in src/pages.
- Use PascalCase for components (e.g., MyComponent), camelCase for variables/functions.
- Write all new code in TypeScript with strict type safety.
- When suggesting refactors, simplify and organize code while preserving existing patterns.
- Check for naming conflicts in the same scope or related files to avoid overrides.

## Contextual Awareness

- When editing a component, consider its usage in parent components or pages (e.g., check @src/pages).
- Do not rename variables/functions used across files without verifying dependencies.
- Reference related files with @ (e.g., @src/lib/supabase.js) for context-aware suggestions.
- When suggesting refactors, ensure Supabase queries or API calls remain functional.

## Framework and Language

- Use functional components with Hooks; avoid class components unless required for legacy reasons.
- Generate strong TypeScript types for props, state, arguments, and return values; use interface for objects, type for unions/intersections.
- Follow project structure: src/components/FeatureName/ComponentName.tsx, ComponentName.module.css, ComponentName.test.tsx.
- Use React Context API for state management; avoid new libraries unless specified.
- For styling, use the project’s UI library (e.g., shadcn/ui, Tailwind); match existing patterns.
- Handle async operations with async/await, providing loading and error states in the UI.
- Include default exports for main components/pages to match Loveable.dev conventions.
- Colocate TypeScript types with components unless shared, then use src/types.

## Supabase Integration

- Use only the Supabase client for database and auth operations (e.g., supabase.from()).
- Follow existing patterns for API calls, including error handling with try-catch.
- Use existing service layers (e.g., @src/lib/api.ts) for API interactions if available.
- Log Supabase errors with code and message (e.g., error.code, error.message).

## Code Generation and Structure

- Generate unit tests for new functions/components using the project’s testing framework (e.g., Vitest).
- Organize imports: 1. Framework (React), 2. External libraries, 3. Internal absolute (@/components), 4. Relative (./utils), 5. Type imports, 6. Styles.
- Use named exports for utilities/constants; default exports for main components/pages.
- Keep functions/components focused on a single responsibility, matching existing patterns.
- Ensure tests cover edge cases, referencing @src/pages or @src/components for context.
- Create new directories only if they follow the pattern (e.g., src/components/FeatureName).
- Respect project’s path aliases (e.g., @/ for src/).

## Error Handling and Robustness

- Use try-catch for async operations; wrap relevant component trees in error boundaries.
- Log errors to console.error with [ProjectName] prefix unless a logging service is configured.
- Include empty, loading, and error states in UI components, using the project’s UI library.
- Ensure error boundaries preserve partial page functionality.

## Documentation and Commenting

- Generate JSDoc/TSDoc for exported functions, classes, and components, explaining intent and context.
- Include references to related files in comments (e.g., “Used in @src/pages/Dashboard.tsx”).
- Document Supabase queries with table and operation (e.g., “Fetches users from 'users' table”).
- Avoid duplicating TypeScript type information in JSDoc.
- Remove TODO comments unless actionable and linked to an issue; preserve Loveable.dev-specific TODOs.
- Use positive, encouraging tone in comments and documentation.

## Accessibility (A11y)

- Include semantic elements and ARIA attributes (e.g., aria-label for buttons, alt for images).
- Ensure interactive elements are keyboard navigable with clear focus indicators.
- Include htmlFor on labels matching input id attributes in forms.
- Prompt for alt text descriptions when adding images.
- Include accessibility checks in unit tests (e.g., using jest-axe).

## Loveable.dev Compatibility

- Preserve special comments like // Generated by Loveable.dev (if present).
- Maintain structural patterns for seamless re-import into Loveable.dev.
- Avoid altering Loveable.dev’s generated markers or patterns critical for regeneration.

## Performance and Security

- Optimize code to prevent unnecessary re-renders (e.g., use useMemo, useCallback).
- Sanitize inputs and follow Supabase security best practices.
- Ensure form validation extends existing schemas (e.g., Yup) when adding fields.

## AI Behavior

- Prefer incremental changes over large refactors to minimize disruption.
- Reference project files (e.g., @README.md) or Supabase docs for context.
- Proactively identify deviations from these rules and suggest fixes.